# Filter output channel elements based on file size or file content

Imagine that you have a process `FOO` whose output are files, and you want to 
pass this output channel to `BAR`, the next process. Your code, at this point, 
could look like:

```Groovy
Channel
  .of('a'..'z')
  | FOO
  | BAR
```

However, there's something else that you want. You don't want all the files 
generated by the `FOO` process to be passed along to the `BAR` process. Only 
files whose size are bigger than 10 bytes should be forwarded to `BAR`. How do 
you do that?

You can use the `filter` channel operator with a closure to describe this logic.
Type the following in your shell to create some files that we will use for our 
next example.

```bash
echo "Hello World" > a.txt
echo "Hola Mundo" > b.txt
echo "Ola mundo" > c.txt
```

With that done, our Nextflow pipeline will read these files and load them into 
the channel `input_data`. The `TO_UPPER_CASE` process will get the content of every one of
 these three files and make it uppercase. The output channel of this process 
will contain three files and the content of each one of them is the uppercase 
version of each of three original files. This will be forwarded to the `PRINT` 
process that prints the content of each file to the standard output (screen), 
but not before some filtering takes place :smiley:

```Groovy
Channel
  .fromPath( '{a,b,c}.txt' )
  .set { input_data }


process TO_UPPER_CASE {
  input:
    path x

  output:
    path 'content.txt'

  script:
    """
    cat $x | tr '[a-z]' '[A-Z'] > content.txt
    """
}


process PRINT {
  debug true

  input:
    path x

  script:
    """
    cat $x
    """
}

workflow {
  TO_UPPER_CASE(input_data)
  TO_UPPER_CASE.out.filter { it.size() > 11.B  } | PRINT
}
```

In the example above, the `PRINT` process will only receive elements that are 
files with a size of over 11 bytes. If you check the size of `a.txt`,  `b.txt`, 
and `c.txt`, you will see that only `a.txt` (that contains `Hello World`, 
originally) has over 11 bytes (it is 12 bytes large). So the output of this 
workflow will be something like:

```console
N E X T F L O W  ~  version 23.02.0-edge
Launching `asd.nf` [nasty_linnaeus] DSL2 - revision: 538d5fdc70
executor >  local (4)
[64/a0b883] process > TO_UPPER_CASE (2) [100%] 3 of 3 ✔
[6f/0e8309] process > PRINT (1)         [100%] 1 of 1 ✔
HELLO WORLD
```

But what if instead of filtering based on file size we want to filter based on 
the content of the files? Let's say we want to keep only files that contain 
somewhere in their content the substring `MUNDO`. We just have to change the 
last line in the workflow scope:

```Groovy
workflow {
  TO_UPPER_CASE(input_data)
  TO_UPPER_CASE.out.filter { it.text.contains('MUNDO')  } | PRINT
}
```

The output:

```console
N E X T F L O W  ~  version 23.02.0-edge
Launching `asd.nf` [cheesy_bose] DSL2 - revision: 541dc60162
executor >  local (5)
[6f/c232b0] process > TO_UPPER_CASE (2) [100%] 3 of 3 ✔
[9a/59f343] process > PRINT (2)         [100%] 2 of 2 ✔
OLA MUNDO

HOLA MUNDO
```
